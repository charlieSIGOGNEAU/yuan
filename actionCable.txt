Action Cable Overview
In this guide, you will learn how Action Cable works and how to use WebSockets to incorporate real-time features into your Rails application.

After reading this guide, you will know:

What Action Cable is and its integration backend and frontend
How to set up Action Cable
How to set up channels
Deployment and Architecture setup for running Action Cable
Skip to article body
Chapter Icon Chapters
What is Action Cable?
Terminology
Connections
Consumers
Channels
Subscribers
Pub/Sub
Broadcastings
Server-Side Components
Connections
Channels
Client-Side Components
Connections
Client-Server Interactions
Streams
Broadcastings
Subscriptions
Passing Parameters to Channels
Rebroadcasting a Message
Full-Stack Examples
Example 1: User Appearances
Example 2: Receiving New Web Notifications
More Complete Examples
Configuration
Subscription Adapter
Allowed Request Origins
Consumer Configuration
Worker Pool Configuration
Client-side Logging
Other Configurations
Running Standalone Cable Servers
In App
Standalone
Notes
Dependencies
Deployment
Testing
1. What is Action Cable?
Action Cable seamlessly integrates WebSockets with the rest of your Rails application. It allows for real-time features to be written in Ruby in the same style and form as the rest of your Rails application, while still being performant and scalable. It's a full-stack offering that provides both a client-side JavaScript framework and a server-side Ruby framework. You have access to your entire domain model written with Active Record or your ORM of choice.

2. Terminology
Action Cable uses WebSockets instead of the HTTP request-response protocol. Both Action Cable and WebSockets introduce some less familiar terminology:

2.1. Connections
Connections form the foundation of the client-server relationship. A single Action Cable server can handle multiple connection instances. It has one connection instance per WebSocket connection. A single user may have multiple WebSockets open to your application if they use multiple browser tabs or devices.

2.2. Consumers
The client of a WebSocket connection is called the consumer. In Action Cable, the consumer is created by the client-side JavaScript framework.

2.3. Channels
Each consumer can, in turn, subscribe to multiple channels. Each channel encapsulates a logical unit of work, similar to what a controller does in a typical MVC setup. For example, you could have a and an , and a consumer could be subscribed to either or both of these channels. At the very least, a consumer should be subscribed to one channel.ChatChannelAppearancesChannel

2.4. Subscribers
When the consumer is subscribed to a channel, they act as a subscriber. The connection between the subscriber and the channel is, surprise-surprise, called a subscription. A consumer can act as a subscriber to a given channel any number of times. For example, a consumer could subscribe to multiple chat rooms at the same time. (And remember that a physical user may have multiple consumers, one per tab/device open to your connection).

2.5. Pub/Sub
Pub/Sub or Publish-Subscribe refers to a message queue paradigm whereby senders of information (publishers), send data to an abstract class of recipients (subscribers), without specifying individual recipients. Action Cable uses this approach to communicate between the server and many clients.

2.6. Broadcastings
A broadcasting is a pub/sub link where anything transmitted by the broadcaster is sent directly to the channel subscribers who are streaming that named broadcasting. Each channel can be streaming zero or more broadcastings.

3. Server-Side Components
3.1. Connections
For every WebSocket accepted by the server, a connection object is instantiated. This object becomes the parent of all the channel subscriptions that are created from thereon. The connection itself does not deal with any specific application logic beyond authentication and authorization. The client of a WebSocket connection is called the connection consumer. An individual user will create one consumer-connection pair per browser tab, window, or device they have open.

Connections are instances of , which extends ActionCable::Connection::Base. In , you authorize the incoming connection and proceed to establish it if the user can be identified.ApplicationCable::ConnectionApplicationCable::Connection

3.1.1. Connection Setup
# app/channels/application_cable/connection.rb
module ApplicationCable
  class Connection < ActionCable::Connection::Base
    identified_by :current_user

    def connect
      self.current_user = find_verified_user
    end

    private
      def find_verified_user
        if verified_user = User.find_by(id: cookies.encrypted[:user_id])
          verified_user
        else
          reject_unauthorized_connection
        end
      end
  end
end
Copy
Here identified_by designates a connection identifier that can be used to find the specific connection later. Note that anything marked as an identifier will automatically create a delegate by the same name on any channel instances created off the connection.

This example relies on the fact that you will already have handled authentication of the user somewhere else in your application, and that a successful authentication sets an encrypted cookie with the user ID.

The cookie is then automatically sent to the connection instance when a new connection is attempted, and you use that to set the . By identifying the connection by this same current user, you're also ensuring that you can later retrieve all open connections by a given user (and potentially disconnect them all if the user is deleted or unauthorized).current_user

If your authentication approach includes using a session, you use cookie store for the session, your session cookie is named and the user ID key is you can use this approach:_sessionuser_id

verified_user = User.find_by(id: cookies.encrypted["_session"]["user_id"])
Copy
3.1.2. Exception Handling
By default, unhandled exceptions are caught and logged to Rails' logger. If you would like to globally intercept these exceptions and report them to an external bug tracking service, for example, you can do so with rescue_from:

# app/channels/application_cable/connection.rb
module ApplicationCable
  class Connection < ActionCable::Connection::Base
    rescue_from StandardError, with: :report_error

    private
      def report_error(e)
        SomeExternalBugtrackingService.notify(e)
      end
  end
end
Copy
3.1.3. Connection Callbacks
ActionCable::Connection::Callbacks provides callback hooks that are invoked when sending commands to the client, such as when subscribing, unsubscribing, or performing an action:

before_command
after_command
around_command
3.2. Channels
A channel encapsulates a logical unit of work, similar to what a controller does in a typical MVC setup. By default, Rails creates a parent class (which extends ActionCable::Channel::Base) for encapsulating shared logic between your channels, when you use the channel generator for the first time.ApplicationCable::Channel

3.2.1. Parent Channel Setup
# app/channels/application_cable/channel.rb
module ApplicationCable
  class Channel < ActionCable::Channel::Base
  end
end
Copy
Your own channel classes could then look like these examples:

# app/channels/chat_channel.rb
class ChatChannel < ApplicationCable::Channel
end
Copy
# app/channels/appearance_channel.rb
class AppearanceChannel < ApplicationCable::Channel
end
Copy
A consumer could then be subscribed to either or both of these channels.

3.2.2. Subscriptions
Consumers subscribe to channels, acting as subscribers. Their connection is called a subscription. Produced messages are then routed to these channel subscriptions based on an identifier sent by the channel consumer.

# app/channels/chat_channel.rb
class ChatChannel < ApplicationCable::Channel
  # Called when the consumer has successfully
  # become a subscriber to this channel.
  def subscribed
  end
end
Copy
3.2.3. Exception Handling
As with , you can also use rescue_from on a specific channel to handle raised exceptions:ApplicationCable::Connection

# app/channels/chat_channel.rb
class ChatChannel < ApplicationCable::Channel
  rescue_from "MyError", with: :deliver_error_message

  private
    def deliver_error_message(e)
      # broadcast_to(...)
    end
end
Copy
3.2.4. Channel Callbacks
ActionCable::Channel::Callbacks provides callback hooks that are invoked during the life cycle of a channel:

before_subscribe
after_subscribe (aliased as on_subscribe)
before_unsubscribe
after_unsubscribe (aliased as on_unsubscribe)
4. Client-Side Components
4.1. Connections
Consumers require an instance of the connection on their side. This can be established using the following JavaScript, which is generated by default by Rails:

4.1.1. Connect Consumer
// app/javascript/channels/consumer.js
// Action Cable provides the framework to deal with WebSockets in Rails.
// You can generate new channels where WebSocket features live using the `bin/rails generate channel` command.

import { createConsumer } from "@rails/actioncable"

export default createConsumer()
Copy
This will ready a consumer that'll connect against on your server by default. The connection won't be established until you've also specified at least one subscription you're interested in having./cable

The consumer can optionally take an argument that specifies the URL to connect to. This can be a string or a function that returns a string that will be called when the WebSocket is opened.

// Specify a different URL to connect to
createConsumer('wss://example.com/cable')
// Or when using websockets over HTTP
createConsumer('https://ws.example.com/cable')

// Use a function to dynamically generate the URL
createConsumer(getWebSocketURL)

function getWebSocketURL() {
  const token = localStorage.get('auth-token')
  return `wss://example.com/cable?token=${token}`
}
Copy
4.1.2. Subscriber
A consumer becomes a subscriber by creating a subscription to a given channel:

// app/javascript/channels/chat_channel.js
import consumer from "./consumer"

consumer.subscriptions.create({ channel: "ChatChannel", room: "Best Room" })

// app/javascript/channels/appearance_channel.js
import consumer from "./consumer"

consumer.subscriptions.create({ channel: "AppearanceChannel" })
Copy
While this creates the subscription, the functionality needed to respond to received data will be described later on.

A consumer can act as a subscriber to a given channel any number of times. For example, a consumer could subscribe to multiple chat rooms at the same time:

// app/javascript/channels/chat_channel.js
import consumer from "./consumer"

consumer.subscriptions.create({ channel: "ChatChannel", room: "1st Room" })
consumer.subscriptions.create({ channel: "ChatChannel", room: "2nd Room" })
Copy
5. Client-Server Interactions
5.1. Streams
Streams provide the mechanism by which channels route published content (broadcasts) to their subscribers. For example, the following code uses stream_from to subscribe to the broadcasting named when the value of the parameter is :chat_Best Room:room"Best Room"

# app/channels/chat_channel.rb
class ChatChannel < ApplicationCable::Channel
  def subscribed
    stream_from "chat_#{params[:room]}"
  end
end
Copy
Then, elsewhere in your Rails application, you can broadcast to such a room by calling broadcast:

ActionCable.server.broadcast("chat_Best Room", { body: "This Room is Best Room." })
Copy
If you have a stream that is related to a model, then the broadcasting name can be generated from the channel and model. For example, the following code uses stream_for to subscribe to a broadcasting like , where is the GlobalID of the Post model.posts:Z2lkOi8vVGVzdEFwcC9Qb3N0LzEZ2lkOi8vVGVzdEFwcC9Qb3N0LzE

class PostsChannel < ApplicationCable::Channel
  def subscribed
    post = Post.find(params[:id])
    stream_for post
  end
end
Copy
You can then broadcast to this channel by calling broadcast_to:

PostsChannel.broadcast_to(@post, @comment)
Copy
5.2. Broadcastings
A broadcasting is a pub/sub link where anything transmitted by a publisher is routed directly to the channel subscribers who are streaming that named broadcasting. Each channel can be streaming zero or more broadcastings.

Broadcastings are purely an online queue and time-dependent. If a consumer is not streaming (subscribed to a given channel), they'll not get the broadcast should they connect later.

5.3. Subscriptions
When a consumer is subscribed to a channel, they act as a subscriber. This connection is called a subscription. Incoming messages are then routed to these channel subscriptions based on an identifier sent by the cable consumer.

// app/javascript/channels/chat_channel.js
import consumer from "./consumer"

consumer.subscriptions.create({ channel: "ChatChannel", room: "Best Room" }, {
  received(data) {
    this.appendLine(data)
  },

  appendLine(data) {
    const html = this.createLine(data)
    const element = document.querySelector("[data-chat-room='Best Room']")
    element.insertAdjacentHTML("beforeend", html)
  },

  createLine(data) {
    return `
      <article class="chat-line">
        <span class="speaker">${data["sent_by"]}</span>
        <span class="body">${data["body"]}</span>
      </article>
    `
  }
})
Copy
5.4. Passing Parameters to Channels
You can pass parameters from the client-side to the server-side when creating a subscription. For example:

# app/channels/chat_channel.rb
class ChatChannel < ApplicationCable::Channel
  def subscribed
    stream_from "chat_#{params[:room]}"
  end
end
Copy
An object passed as the first argument to becomes the params hash in the cable channel. The keyword is required:subscriptions.createchannel

// app/javascript/channels/chat_channel.js
import consumer from "./consumer"

consumer.subscriptions.create({ channel: "ChatChannel", room: "Best Room" }, {
  received(data) {
    this.appendLine(data)
  },

  appendLine(data) {
    const html = this.createLine(data)
    const element = document.querySelector("[data-chat-room='Best Room']")
    element.insertAdjacentHTML("beforeend", html)
  },

  createLine(data) {
    return `
      <article class="chat-line">
        <span class="speaker">${data["sent_by"]}</span>
        <span class="body">${data["body"]}</span>
      </article>
    `
  }
})
Copy
# Somewhere in your app this is called, perhaps
# from a NewCommentJob.
ActionCable.server.broadcast(
  "chat_#{room}",
  {
    sent_by: "Paul",
    body: "This is a cool chat app."
  }
)
Copy
5.5. Rebroadcasting a Message
A common use case is to rebroadcast a message sent by one client to any other connected clients.

# app/channels/chat_channel.rb
class ChatChannel < ApplicationCable::Channel
  def subscribed
    stream_from "chat_#{params[:room]}"
  end

  def receive(data)
    ActionCable.server.broadcast("chat_#{params[:room]}", data)
  end
end
Copy
// app/javascript/channels/chat_channel.js
import consumer from "./consumer"

const chatChannel = consumer.subscriptions.create({ channel: "ChatChannel", room: "Best Room" }, {
  received(data) {
    // data => { sent_by: "Paul", body: "This is a cool chat app." }
  }
})

chatChannel.send({ sent_by: "Paul", body: "This is a cool chat app." })
Copy
The rebroadcast will be received by all connected clients, including the client that sent the message. Note that params are the same as they were when you subscribed to the channel.

6. Full-Stack Examples
The following setup steps are common to both examples:

Set up your connection.
Set up your parent channel.
Connect your consumer.
6.1. Example 1: User Appearances
Here's a simple example of a channel that tracks whether a user is online or not and what page they're on. (This is useful for creating presence features like showing a green dot next to a username if they're online).

Create the server-side appearance channel:

# app/channels/appearance_channel.rb
class AppearanceChannel < ApplicationCable::Channel
  def subscribed
    current_user.appear
  end

  def unsubscribed
    current_user.disappear
  end

  def appear(data)
    current_user.appear(on: data["appearing_on"])
  end

  def away
    current_user.away
  end
end
Copy
When a subscription is initiated the callback gets fired, and we take that opportunity to say "the current user has indeed appeared". That appear/disappear API could be backed by Redis, a database, or whatever else.subscribed

Create the client-side appearance channel subscription:

// app/javascript/channels/appearance_channel.js
import consumer from "./consumer"

consumer.subscriptions.create("AppearanceChannel", {
  // Called once when the subscription is created.
  initialized() {
    this.update = this.update.bind(this)
  },

  // Called when the subscription is ready for use on the server.
  connected() {
    this.install()
    this.update()
  },

  // Called when the WebSocket connection is closed.
  disconnected() {
    this.uninstall()
  },

  // Called when the subscription is rejected by the server.
  rejected() {
    this.uninstall()
  },

  update() {
    this.documentIsActive ? this.appear() : this.away()
  },

  appear() {
    // Calls `AppearanceChannel#appear(data)` on the server.
    this.perform("appear", { appearing_on: this.appearingOn })
  },

  away() {
    // Calls `AppearanceChannel#away` on the server.
    this.perform("away")
  },

  install() {
    window.addEventListener("focus", this.update)
    window.addEventListener("blur", this.update)
    document.addEventListener("turbo:load", this.update)
    document.addEventListener("visibilitychange", this.update)
  },

  uninstall() {
    window.removeEventListener("focus", this.update)
    window.removeEventListener("blur", this.update)
    document.removeEventListener("turbo:load", this.update)
    document.removeEventListener("visibilitychange", this.update)
  },

  get documentIsActive() {
    return document.visibilityState === "visible" && document.hasFocus()
  },

  get appearingOn() {
    const element = document.querySelector("[data-appearing-on]")
    return element ? element.getAttribute("data-appearing-on") : null
  }
})
Copy
6.1.1. Client-Server Interaction
Client connects to the Server via . (). The Server identifies this connection by .createConsumer()consumer.jscurrent_user

Client subscribes to the appearance channel via . (consumer.subscriptions.create({ channel: "AppearanceChannel" })appearance_channel.js)

Server recognizes a new subscription has been initiated for the appearance channel and runs its callback, calling the method on . (subscribedappearcurrent_userappearance_channel.rb)

Client recognizes that a subscription has been established and calls (), which in turn calls and . calls on the server, and supplies a data hash of . This is possible because the server-side channel instance automatically exposes all public methods declared on the class (minus the callbacks), so that these can be reached as remote procedure calls via a subscription's method.connectedappearance_channel.jsinstallappearappearAppearanceChannel#appear(data){ appearing_on: this.appearingOn }perform

Server receives the request for the action on the appearance channel for the connection identified by (). Server retrieves the data with the key from the data hash and sets it as the value for the key being passed to .appearcurrent_userappearance_channel.rb:appearing_on:oncurrent_user.appear

6.2. Example 2: Receiving New Web Notifications
The appearance example was all about exposing server functionality to client-side invocation over the WebSocket connection. But the great thing about WebSockets is that it's a two-way street. So, now, let's show an example where the server invokes an action on the client.

This is a web notification channel that allows you to trigger client-side web notifications when you broadcast to the relevant streams:

Create the server-side web notifications channel:

# app/channels/web_notifications_channel.rb
class WebNotificationsChannel < ApplicationCable::Channel
  def subscribed
    stream_for current_user
  end
end
Copy
Create the client-side web notifications channel subscription:

// app/javascript/channels/web_notifications_channel.js
// Client-side which assumes you've already requested
// the right to send web notifications.
import consumer from "./consumer"

consumer.subscriptions.create("WebNotificationsChannel", {
  received(data) {
    new Notification(data["title"], { body: data["body"] })
  }
})
Copy
Broadcast content to a web notification channel instance from elsewhere in your application:

# Somewhere in your app this is called, perhaps from a NewCommentJob
WebNotificationsChannel.broadcast_to(
  current_user,
  title: "New things!",
  body: "All the news fit to print"
)
Copy
The call places a message in the current subscription adapter's pubsub queue under a separate broadcasting name for each user. For a user with an ID of 1, the broadcasting name would be .WebNotificationsChannel.broadcast_toweb_notifications:1

The channel has been instructed to stream everything that arrives at directly to the client by invoking the callback. The data passed as an argument is the hash sent as the second parameter to the server-side broadcast call, JSON encoded for the trip across the wire and unpacked for the data argument arriving as .web_notifications:1receivedreceived

6.3. More Complete Examples
See the rails/actioncable-examples repository for a full example of how to set up Action Cable in a Rails app and adding channels.

7. Configuration
Action Cable has two required configurations: a subscription adapter and allowed request origins.

7.1. Subscription Adapter
By default, Action Cable looks for a configuration file in . The file must specify an adapter for each Rails environment. See the Dependencies section for additional information on adapters.config/cable.yml

development:
  adapter: async

test:
  adapter: test

production:
  adapter: redis
  url: redis://10.10.3.153:6381
  channel_prefix: appname_production
Copy
7.1.1. Adapter Configuration
Below is a list of the subscription adapters available for end-users.

7.1.1.1. Async Adapter
The async adapter is intended for development/testing and should not be used in production.

The async adapter only works within the same process, so for manually triggering cable updates from a console and seeing results in the browser, you must do so from the web console (running inside the dev process), not a terminal started via ! Add to any action or any ERB template view to make the web console appear.bin/rails consoleconsole

7.1.1.2. Redis Adapter
The Redis adapter requires users to provide a URL pointing to the Redis server. Additionally, a may be provided to avoid channel name collisions when using the same Redis server for multiple applications. See the Redis Pub/Sub documentation for more details.channel_prefix

The Redis adapter also supports SSL/TLS connections. The required SSL/TLS parameters can be passed in key in the configuration YAML file.ssl_params

production:
  adapter: redis
  url: rediss://10.10.3.153:tls_port
  channel_prefix: appname_production
  ssl_params:
    ca_file: "/path/to/ca.crt"
Copy
The options given to are passed directly to the method and can be any valid attribute of the SSL context. Please refer to the OpenSSL::SSL::SSLContext documentation for other available attributes.ssl_paramsOpenSSL::SSL::SSLContext#set_params

If you are using self-signed certificates for redis adapter behind a firewall and opt to skip certificate check, then the ssl should be set as .verify_modeOpenSSL::SSL::VERIFY_NONE

It is not recommended to use in production unless you absolutely understand the security implications. In order to set this option for the Redis adapter, the config should be .VERIFY_NONEssl_params: { verify_mode: <%= OpenSSL::SSL::VERIFY_NONE %> }

7.1.1.3. PostgreSQL Adapter
The PostgreSQL adapter uses Active Record's connection pool, and thus the application's database configuration, for its connection. This may change in the future. #27214config/database.yml

PostgreSQL has a 8000 bytes limit on (the command used under the hood for sending notifications) which might be a constraint when dealing with large payloads.NOTIFY

7.2. Allowed Request Origins
Action Cable will only accept requests from specified origins, which are passed to the server config as an array. The origins can be instances of strings or regular expressions, against which a check for the match will be performed.

config.action_cable.allowed_request_origins = ["https://rubyonrails.com", %r{http://ruby.*}]
Copy
To disable and allow requests from any origin:

config.action_cable.disable_request_forgery_protection = true
Copy
By default, Action Cable allows all requests from localhost:3000 when running in the development environment.

7.3. Consumer Configuration
To configure the URL, add a call to action_cable_meta_tag in your HTML layout HEAD. This uses a URL or path typically set via config.action_cable.url in the environment configuration files.

7.4. Worker Pool Configuration
The worker pool is used to run connection callbacks and channel actions in isolation from the server's main thread. Action Cable allows the application to configure the number of simultaneously processed threads in the worker pool.

config.action_cable.worker_pool_size = 4
Copy
Also, note that your server must provide at least the same number of database connections as you have workers. The default worker pool size is set to 4, so that means you have to make at least 4 database connections available. You can change that in through the attribute.config/database.ymlpool

7.5. Client-side Logging
Client-side logging is disabled by default. You can enable this by setting the to true.ActionCable.logger.enabled

import * as ActionCable from '@rails/actioncable'

ActionCable.logger.enabled = true
Copy
7.6. Other Configurations
The other common option to configure is the log tags applied to the per-connection logger. Here's an example that uses the user account id if available, else "no-account" while tagging:

config.action_cable.log_tags = [
  -> request { request.env["user_account_id"] || "no-account" },
  :action_cable,
  -> request { request.uuid }
]
Copy
For a full list of all configuration options, see the class.ActionCable::Server::Configuration

8. Running Standalone Cable Servers
Action Cable can either run as part of your Rails application, or as a standalone server. In development, running as part of your Rails app is generally fine, but in production you should run it as a standalone.

8.1. In App
Action Cable can run alongside your Rails application. For example, to listen for WebSocket requests on , specify that path to config.action_cable.mount_path:/websocket

# config/application.rb
class Application < Rails::Application
  config.action_cable.mount_path = "/websocket"
end
Copy
You can use to connect to the cable server if action_cable_meta_tag is invoked in the layout. Otherwise, a path is specified as first argument to (e.g. ).ActionCable.createConsumer()createConsumerActionCable.createConsumer("/websocket")

For every instance of your server you create, and for every worker your server spawns, you will also have a new instance of Action Cable, but the Redis or PostgreSQL adapter keeps messages synced across connections.

8.2. Standalone
The cable servers can be separated from your normal application server. It's still a Rack application, but it is its own Rack application. The recommended basic setup is as follows:

# cable/config.ru
require_relative "../config/environment"
Rails.application.eager_load!

run ActionCable.server
Copy
Then to start the server:

$ bundle exec puma -p 28080 cable/config.ru
Copy
This starts a cable server on port 28080. To tell Rails to use this server, update your config:

# config/environments/development.rb
Rails.application.configure do
  config.action_cable.mount_path = nil
  config.action_cable.url = "ws://localhost:28080" # use wss:// in production
end
Copy
Finally, ensure you have configured the consumer correctly.

8.3. Notes
The WebSocket server doesn't have access to the session, but it has access to the cookies. This can be used when you need to handle authentication. You can see one way of doing that with Devise in this article.

9. Dependencies
Action Cable provides a subscription adapter interface to process its pubsub internals. By default, asynchronous, inline, PostgreSQL, and Redis adapters are included. The default adapter in new Rails applications is the asynchronous () adapter.async

The Ruby side of things is built on top of websocket-driver, nio4r, and concurrent-ruby.

10. Deployment
Action Cable is powered by a combination of WebSockets and threads. Both the framework plumbing and user-specified channel work are handled internally by utilizing Ruby's native thread support. This means you can use all your existing Rails models with no problem, as long as you haven't committed any thread-safety sins.

The Action Cable server implements the Rack socket hijacking API, thereby allowing the use of a multi-threaded pattern for managing connections internally, irrespective of whether the application server is multi-threaded or not.

Accordingly, Action Cable works with popular servers like Unicorn, Puma, and Passenger.

11. Testing
You can find detailed instructions on how to test your Action Cable functionality in the testing guide.

Feedback
You're encouraged to help improve the quality of this guide.

Please contribute if you see any typos or factual errors. To get started, you can read our documentation contributions section.

You may also find incomplete content or stuff that is not up to date. Please do add any missing documentation for main. Make sure to check Edge Guides first to verify if the issues are already fixed or not on the main branch. Check the Ruby on Rails Guides Guidelines for style and conventions.

If for whatever reason you spot something to fix but cannot patch it yourself, please open an issue.

And last but not least, any kind of discussion regarding Ruby on Rails documentation is very welcome on the official Ruby on Rails Forum.

