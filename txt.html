<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Image Viewer</title>
    <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

    <script>
  // SCÈNE
  const scene = new THREE.Scene();

  // CAMÉRA
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(0, 3, -2.2);
  camera.rotation.set(THREE.MathUtils.degToRad(-120), 0, THREE.MathUtils.degToRad(180));

  // RENDU
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // LUMIÈRE
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(0, 1, 1).normalize();
  scene.add(light);

  // PLAN AVEC IMAGE
  let plane;
  const textureLoader = new THREE.TextureLoader();
  textureLoader.load('test.jpg', (texture) => {
    const geometry = new THREE.PlaneGeometry(4, 3);
    const material = new THREE.MeshBasicMaterial({ map: texture });
    plane = new THREE.Mesh(geometry, material);
    plane.rotation.x = -Math.PI / 2;
    scene.add(plane);
  });

  // Coordonnées monde à partir de la souris
  function getMouseWorld(e) {
    const rect = renderer.domElement.getBoundingClientRect();
    const ndc = new THREE.Vector2(
      ((e.clientX - rect.left) / rect.width) * 2 - 1,
      -((e.clientY - rect.top) / rect.height) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(ndc, camera);
    const planeSurface = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // Y = 0
    const point = new THREE.Vector3();
    raycaster.ray.intersectPlane(planeSurface, point);
    return point;
  }

  let isDragging = false;
  let dragStart = null;
  let planeStartPosition = null;

  window.addEventListener('mousedown', (e) => {
    if (!plane) return;
    
    isDragging = true;
    dragStart = getMouseWorld(e);
    planeStartPosition = plane.position.clone();
  });

  window.addEventListener('mousemove', (e) => {
    if (!isDragging || !dragStart || !plane) return;

    const dragCurrent = getMouseWorld(e);
    if (!dragCurrent) return;

    // Calculer le déplacement et l'appliquer au plan
    const delta = new THREE.Vector3().subVectors(dragStart, dragCurrent);
    plane.position.copy(planeStartPosition.clone().sub(delta));
  });

  window.addEventListener('mouseup', () => {
    isDragging = false;
  });

  window.addEventListener('wheel', (e) => {
    if (!plane) return;

    e.preventDefault();
    
    // Obtenir les coordonnées du point ciblé par la souris
    const mousePoint = getMouseWorld(e);
    if (!mousePoint) return;
    
    // Calculer le vecteur du centre du plan vers le point de la souris
    const pointToPlaneDelta = new THREE.Vector3().subVectors(mousePoint, plane.position);
    
    // Facteur de zoom (augmentation ou diminution)
    const scaleFactor = e.deltaY < 0 ? 1.1 : 0.9;
    
    // Appliquer le zoom
    plane.scale.multiplyScalar(scaleFactor);
    
    // Ajuster la position du plan pour que le point sous la souris reste fixe
    // La formule est: newPosition = oldPosition + (1-scaleFactor) * (mousePoint-oldPosition)
    plane.position.add(
      pointToPlaneDelta.multiplyScalar(1 - scaleFactor)
    );
    
  }, { passive: false });

  // RENDU
  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
    </script>
</body>
</html>
